<<<<<<< HEAD
The multi-agent path finding problem (MAPF) is more challenging than the single-agent problem due to the high dimension of its configuration space. Broadly speaking, there are two approaches to solve this problem: planning and reacting. In the planning approach, collision-free paths are generated ahead of time, whereas the reactive approach uses online collision avoidance schemes while encountering hazardous situations. In this chapter, we introduce the various approaches of tackling problem. 

\section{Graph Search Methods}
These approaches compute the path by applying the graph-search algorithms on the configuration space of the multi-robot system, which is the Cartesian product of the configuration spaces of each robot. Here, robot-robot collisions are expressed as configuration space obstacles. The full configuration space grows exponentially with the number of robots, thus making the standard search algorithms computationally infeasible. 

It is not necessary to plan in this space as the robots are usually well separated in the workspace, and collisions are infrequent. Some works generate feasible results by exploiting this decoupled property of the system. In this section, we discuss two such methods: M* \cite{wagner2011m} and conflict based search \cite{sharon2015conflict}. These methods have proven to produce remarkable results for cases with high congestion. 
\subsection{M* Search}
Initially, M* algorithm plans for each robot separately, without considering collisions. This is a good starting point for multi-robot planning as no path can be cheaper than this. When collisions occur, planning is performed in the joint configuration space (see Figure.~\ref{fig:mstar}) of the robots involved in the collision while uninvolved robots proceed independently. When the collision is bypassed, planning continues to proceed in low dimensional individual spaces. 

\begin{figure}
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \includegraphics[width=\textwidth]{./images/m_star_a.png}
        \caption{Representation of search space in M* algorithm}
        \label{fig:mstara}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
    \begin{subfigure}[b]{0.55\textwidth}
        \includegraphics[width=\textwidth]{./images/m_star_b.png}
        \caption{Motion of multiple robots in the shared workspace}
        \label{fig:mstarb}
    \end{subfigure}
    \caption{Visualization of the variable dimensionality workspace in M* algorithm. When two robots collide, the local dimensionality is increased to 2 (represented by a square). Similarly, when three robots collide the dimensionality is 3 (cube). \cite{wagner2011m} }\label{fig:mstar}
\end{figure}

Like A* algorithm, M* explores a list of vertices sorted based on the sum of the cost of the cheapest path and a heuristic cost. M* considers only a limited set of neighbours determined by a \textit{collision set}, thus minimizing the dimensionality. M* can be seen as performing A* search in a  dynamically updating graph, $G^\#$. M* algorithm can handle problems involving a high number of robots, while retaining bounded optimality and \textit{completeness}. 


%M* algorithm was proven to be \textit{complete}. Moreover, it is capable of scaling to problems involving high dimension of robots, while maintaining completeness and bounded optimality. 
The uncertainties of the poses, inherent to robotics, was taken into consideration in UM* \cite{Wagner2017PathPF}. In this approach, planning is done in the belief space to account for the uncertainties. Then, a scheme similar to M* is implemented. 
\subsection{Conflict Based Search}
Conflict-Based Search (CBS) is a bounded sub-optimal two-level MAPF solver. The top level solves a binary \textit{constraint tree} (CT), whose nodes consists of a set of constraints, a single solution, and the cost of solution. The low level of CBS searches for a plan that satisfies all the constraints in a node $N$. If a node is conflict-free, it is returned as the solution. Otherwise, CBS splits node $N$ based on one of the conflicts. Let $<a_i, a_j, v, t>$ represent the conflict between agents $a_i$ and $a_j$ at vertex $v$ at time-step $t$. Now, $N$ is split into two children node, one with the constraint $<a_i, v, t>$ and the other with $<a_j,v,t>$. By doing so, the solver imposes a constraint on only one agent at a time. 

An example of this node expansion scheme is shown in Figure.~\ref{fig:cbs}. In this problem, each mouse (agent) must find a path to cheese (goal). Node $R$ is initialized with no constraints. The shortest paths generated has a collision $<1,2,D,2>$. Therefore, two nodes, $U$ and $V$, are generated with constraints $<1,D,2>$ and $<2,D,2>$ respectively. This leads to collision free solutions. As this search method is exponential in the number of conflicts encountered, as opposed to the number of agents, it leads to superior results. 

Since solving MAPF problems are optimally NP-hard, optimal solutions like M* and CBS are feasible only for low number of agents. Therefore, it is common to use bounded-suboptimal solutions for higher number of agents. Koenig et al. \cite{cohen2016bounded} uses user-provided highways to generate suboptimal paths for a large number of robots. 

The graph plans from these grid based search methods cannot be directly interpreted as trajectory results as they do not consider the kinematic and dynamics constraints of the robot. \cite{honig2016multi} deals with this problem by post-processing the output of the MAPF solvers using a simple temporal network. 

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{./images/CBS}
\caption{Example of CBS: (I) MAPF instance, and (II) its Constraint-Tree (CT)}
\label{fig:cbs}
\end{figure}

\section{Continuous optimization schemes}
Some researchers the MAPF problem in a continuous setting by formulating it as an optimisation problem with the trajectories defined by its decision variables. These methods generate smooth solutions for small fleets of robots. 

Dâ€™Andrea et al. \cite{augugliaro2012generation}, solves this problem using sequential quadratic programming. Suppose we have $N$ vehicles, and $K$ time steps. The position of the vehicle $i$ at time-step $k$ is denoted as $p_i[k]$. The velocity and acceleration equations are:
\begin{align}
\begin{split}
&v_i[k+1]=v_i[k]+ha_i[k]\\
&p_i[k+1]=p_i[k] + hv_i[k] + \frac{h^2}{2}a_i[k],
\end{split}
\end{align}
The optimization variable $\chi\in \mathbb{R}^{3NK}$ is made of the accelerations of the vehicles at each time step. The velocity and acceleration of the vehicle $i$ at time $k$ can also be written as:
\begin{align}
\begin{split}
&v_i[k]=v[1] + h(a_i[1] + a_i[2] +\ldots+a_i[k-1])\\
&p_i[k]=p_i[1] + h(k-1)v_i[1] + \frac{h^2}{2}\left((2k-3)a_i[1] + (2k-5)a_i[2]+\ldots+a_i[k-1]\right))
\end{split}
\end{align}
The objective function is the sum of the total thrust at each step can be written as:
\begin{align}
f_0=\sum_{i=1}^N\sum_{k=1}^K\left\Vert a_i[k]+g\right\Vert
\end{align}
where, $g$ is the gravity vector. This function can be expressed as a quadratic function of the optimization variable $\chi$. The fixed initial and final states gives rise to some equality constraints. Similarly, the limits on the workspace, as well as the dynamics limits of the quadrotor creates inequality constraints on the position, velocity, acceleration, and jerk. If the robots should be at a safe distance of $R$ between each other to avoid collisions, the following non-convex constraint must be imposed:
\begin{align}
\Vert p_i[k]-p_j[k]\Vert_2 \geq R
\end{align} 
Using sequential convex programming, these constraints can be replaced with convex approximations around a previous solution $\chi^q$ using a first order Taylor expansion. The minimization problem can now be written as:
\begin{align}
\begin{split}
\min \quad &f_0(\chi) = \chi^\top P\chi + q^\top \chi + r \\
\text{s.t.} \quad &A_{eq}\chi=b_{eq}\\&A_{in}\chi\leq b_{in}
\end{split}
\end{align}
The optimum solution was found using QP. A demonstration of this method can be seen in Figure

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{./images/dandrea_scp.png}
\caption{Multi-agent trajectory planning using sequential quadratic programming. \cite{augugliaro2012generation}}
\end{figure}

In \cite{mellinger2012mixed}, a Mixed-Integer Quadratic Program (MIQP) is solved to generate feasible paths. These methods are capable of creating smooth, optimal solutions. However, these methods are often tightly and hence do not scale  up well to large teams. 
\section{Planning with time offsets}

\section{Velocity Profile Methods}
<<<<<<< HEAD
Some researchers address this problem using velocity profile methods\cite{peng2005coordinating}. First, the optimal path for each robot is computed without considering robot-robot collisions. Then the robots are coordinated so that they do not collide. It must be noted that the robots always stay at their best paths. 

Let $\mathcal{S}_i=[0,1]$  be the set of parameters that represent the position of the robot along its trajectory. These parameters constitute the coordination space, with $s_{init}=(0,0,\ldots,0)$ and $s_{goal}=(1,1,\ldots,1)$. A collision pair $\mathcal{CP}_{ij}$ is defined as a pair of configurations where robots $\mathcal{A}_i$ and $\mathcal{A}_j$ collide. Each robots paths are decomposed into collision segments and collision-free segments. 

Since each robot has dynamics constraints on its velocity and accelerations, there is an upper and lower limit to the time in which it can traverse a segment $k$ represented by $\Delta T_{ik}^{max}$ and $\Delta T_{ik}^{min}$ respectively. If $\tau_{ik}$ is the traversal time of robot $i$ in segment $k$, the traversal time constraint can be written as:
\begin{align}
\Delta T_{ik}^{max}\geq \tau_{ik} \geq \Delta T_{ik}^{min}
\end{align}
Let $k$ and $h$ be the collision zones for two robots $\mathcal{A}_i$ and $\mathcal{A}_j$ respectively. If $\mathcal{A}_i$ exits segment $k$ before $\mathcal{A}_j$ enters segment $h$, $t_{jh}\geq t_{i(k+1)}$, or if $\mathcal{A}_j$ exists first, $t_{ik}\geq t_{j(h+1)}$. These constraints can be written with a binary variable $\delta_{ijkh}\in {0,1}$ and a sufficiently large number $M$ as:
\begin{align}
\begin{split}
&t_{jh}-t_{i(k+1)} + M(1-\delta_{ijkh})\geq 0\\
&t_{ik}-t_{j(h+1)}+M\delta_{ijkh} \geq 0
\end{split}
\end{align}
A feasible solution was obtained by solving the following Mixed-Integer Linear Problem with the set of traversal times as the decision variables $\tau_{ij}$ and the binary variables $\delta_{ijkh}$ as the decision variables:
\begin{align}
\begin{split}
\min \quad &C_{max}\\
\text{s.t.} \quad &C_{max}\geq t_{i,last} + \tau_{last}~~~\text{for i=1...n}\\
&t_{ik}\geq 0\\
&t_{i(k+1)}=t_{ik}+\tau_{ik}\\
&\Delta T_{ik}^{max}\geq \tau_{ik} \geq \Delta T_{ik}^{min}\\
&t_{jh}-t_{i(k+1)} + M(1-\delta_{ijkh})\geq 0\\
&t_{ik}-t_{j(h+1)}+M\delta_{ijkh} \geq 0\\
&\delta_{ijkh}\in {0,1}
\end{split}
\end{align}

This method can be extended to handle \textit{kineodynamic} constraints well. However, this doesn't lead to a global time-optimal solution as the free space is not fully exploited.
\section{Collision-Avoidance Approaches}
=======
\section{Collision Avoidance based Methods}
>>>>>>> parent of f7b2d16... planning with goal assignment
\subsection{Nonlinear Model Predictive Control}
\subsection{Velocity Obstacle}

\section{Spline-based refinement of Waypoints}
=======
 \subsection{Graph Search Methods}
 \subsubsection{M*}
 \subsubsection{Conflict based search}
 
 \subsection{Continuous optimization schemes}

 \subsection{Planning with time offsets}

 \subsection{Velocity Profile Methods}

 \subsection{Collision Avoidance based Methods}
 \subsubsection{Nonlinear Model Predictive Control}
 \subsubsection{Velocity Obstacle}

 \subsection{Spline-based refinement of Waypoints}
>>>>>>> parent of 803a603... completed chapter 1: basics of path planning
